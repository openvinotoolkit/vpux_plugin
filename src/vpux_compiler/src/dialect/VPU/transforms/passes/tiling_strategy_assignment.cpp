//
// Copyright (C) 2023 Intel Corporation
// SPDX-License-Identifier: Apache 2.0
//

#include "vpux/compiler/core/tiling.hpp"
#include "vpux/compiler/core/type_interfaces.hpp"
#include "vpux/compiler/dialect/VPU/transforms/passes.hpp"
#include "vpux/compiler/dialect/VPU/utils/generate_tiling.hpp"
#include "vpux/compiler/dialect/VPU/utils/manual_strategy_utils.hpp"
#include "vpux/compiler/dialect/VPU/utils/op_tiling_cache.hpp"
#include "vpux/compiler/dialect/VPU/utils/sibling_ops_analysis.hpp"

using namespace vpux;

namespace {

//
// TilingStrategyAssignment
//
// There are three modes of tiling strategies as defined in vpux::TilingMode:
// 1. ISOLATED tiling: Split operations with smallest tiling number to make them fit into CMX
// 2. PIPELINING tiling: Overlap the DPU time of earlier sub-tile with the DMA time of the later ones
//              Two possible scenarios where the PIPELINING could be triggered:
//              a). When ISOLATED tiling is required, the tiling number will be increased to satisfy PIPELINING
//              b). When the constant weights of an operation is larger than the threshold
//                  tiling number will be increased to satisfy PIPELINING
//                  even though the operation doesn't require ISOLATED tiling originally
//              A precondition is that a feasible tiling strategy must exist to make PIPELINING work
//              Otherwise it will fallback to ISOLATED tiling or non-tiling
// 3. PREFETCHING tiling: Overlap the DPU time of parent operation with the DMA time the child
//

//
// TilingStrategyAssignmentPass
//
class TilingStrategyAssignmentPass final : public VPU::TilingStrategyAssignmentBase<TilingStrategyAssignmentPass> {
public:
    explicit TilingStrategyAssignmentPass(bool enablePrefetchTiling, bool enableVpunnCostForTiling,
                                          StringRef enableShaveDDRAccessOptimization, Logger log)
            : _enablePrefetchTiling(enablePrefetchTiling),
              _enableVpunnCostForTiling(enableVpunnCostForTiling),
              _shaveDDRAccessOptimizationMode(
                      vpux::VPU::getShaveDDRAccessOptimizationMode(enableShaveDDRAccessOptimization)) {
        Base::initLogger(log, Base::getArgumentName());
    }

    mlir::LogicalResult initialize(mlir::MLIRContext* ctx) final;

private:
    void safeRunOnFunc() final;
    void assignStrategy(VPU::TilingBuilderOpInterface origOp);

    bool _enablePrefetchTiling = true;
    bool _enableVpunnCostForTiling = false;
    VPU::EnableShaveDDRAccessOptimization _shaveDDRAccessOptimizationMode;
    std::shared_ptr<vpux::VPU::LayerCostModel> _costModel = nullptr;
};

mlir::LogicalResult TilingStrategyAssignmentPass::initialize(mlir::MLIRContext* ctx) {
    if (mlir::failed(Base::initialize(ctx))) {
        return mlir::failure();
    }
    if (tilingMode.hasValue()) {
        _log.trace("Overloading the default value {0} of the '_enablePrefetchTiling' field to the value {1} of the "
                   "pass option 'tilingMode' generated by MLIR",
                   _enablePrefetchTiling, tilingMode.getValue());
        _enablePrefetchTiling = tilingMode.getValue() == "PREFETCH";
    }
    if (enableVpunnCostForTiling.hasValue()) {
        _log.trace("Overloading the default value {0} of the '_enableVpunnCostForTiling' field to the value {1} of the "
                   "pass option "
                   "'enableVpunnCostForTiling' generated by MLIR",
                   _enableVpunnCostForTiling, enableVpunnCostForTiling);
        _enableVpunnCostForTiling = enableVpunnCostForTiling;
    }
    if (enableShaveDDRAccessOptimization.hasValue()) {
        _shaveDDRAccessOptimizationMode =
                vpux::VPU::getShaveDDRAccessOptimizationMode(enableShaveDDRAccessOptimization);
    }
    return mlir::success();
}

void TilingStrategyAssignmentPass::assignStrategy(VPU::TilingBuilderOpInterface origOp) {
    _log.trace("Assign: '{0}' at '{1}'", origOp->getName(), origOp->getLoc());
    auto op = origOp.getOperation();
    auto defaultTilingMode = getTilingSupportedMode(origOp, _enablePrefetchTiling, _log);

    mlir::FailureOr<OutputTiling> tiles = mlir::failure();
    // Temporarily not assign tiling strategy to NCE ops with INT4 weights based on VPUNN cost.
    // This can be removed when VPUNN is upgraded to support INT4 data type, tracked in E#113316.
    if (_costModel == nullptr || !mlir::isa<VPU::NCEOpInterface>(op) || VPU::isNCEWithInt4Weights(op)) {
        tiles = getLayerTilingStrategy(origOp, _enablePrefetchTiling, _log);
    } else {
        auto tileDimOrder = getTileDimOrder(op, defaultTilingMode, _log);
        tiles = vpux::VPU::getHWLayerTilingStrategyBasedOnCost(op, defaultTilingMode, tileDimOrder, _costModel, _log);
    }
    VPUX_THROW_WHEN(mlir::failed(tiles), "Invalid tiling strategy for {0}", origOp->getLoc());

    origOp->setAttr(tilingStrategy, getIntArrayAttr(op->getContext(), tiles.value()[0].axis));
}

void TilingStrategyAssignmentPass::safeRunOnFunc() {
    auto func = getOperation();
    auto siblingsOpsAnalysis = getAnalysis<VPU::SiblingOpsAnalysis>();
    if (_enableVpunnCostForTiling) {
        _log.trace("Using VPUNN DPU+DMA Costs to get tiling strategy");
        _costModel = std::make_shared<vpux::VPU::LayerCostModel>(
                vpux::VPU::LayerCostModel(func, _enablePrefetchTiling, _log, siblingsOpsAnalysis));
    }

    const auto assignWithOnlyCMXAccessStrategy = [&](mlir::Operation* op) {
        auto tilingOp = mlir::dyn_cast<VPU::TilingBuilderOpInterface>(op);
        if (tilingOp != nullptr && VPU::opNeedsTiling(op, _enablePrefetchTiling, _log)) {
            assignStrategy(tilingOp);
        }
    };

    const auto assignStrategyWithDDRAccess = [&](mlir::Operation* op) {
        auto ddrAccessOp = mlir::dyn_cast<VPU::DDRAccessOpInterface>(op);
        if (ddrAccessOp != nullptr && ddrAccessOp.isDDRAccessNecessaryOrBeneficial(_log)) {
            return;
        }
        assignWithOnlyCMXAccessStrategy(op);
    };

    if (_shaveDDRAccessOptimizationMode == VPU::EnableShaveDDRAccessOptimization::TRUE) {
        func->walk(assignStrategyWithDDRAccess);
    } else {
        func->walk(assignWithOnlyCMXAccessStrategy);
    }

    auto& cache = VPU::OpTilingCache::instance();
    cache.printStats(_log);
    cache.cleanUp();
}
}  // namespace

std::unique_ptr<mlir::Pass> vpux::VPU::createTilingStrategyAssignmentPass(bool enablePrefetchTiling,
                                                                          bool enableVpunnCostForTiling,
                                                                          StringRef enableShaveDDRAccessOptimization,
                                                                          Logger log) {
    return std::make_unique<TilingStrategyAssignmentPass>(enablePrefetchTiling, enableVpunnCostForTiling,
                                                          enableShaveDDRAccessOptimization, log);
}
