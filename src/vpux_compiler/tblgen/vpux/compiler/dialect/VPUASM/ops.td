//
// Copyright (C) 2022 Intel Corporation.
// SPDX-License-Identifier: Apache 2.0
//

#ifndef VPUX_COMPILER_DIALECT_VPUASM_OPS
#define VPUX_COMPILER_DIALECT_VPUASM_OPS

include "vpux/compiler/dialect/VPUASM/attributes.td"
include "vpux/compiler/dialect/VPUASM/ops_interfaces.td"
include "vpux/compiler/dialect/VPUASM/dialect.td"

include "vpux/compiler/core/attributes.td"
include "vpux/compiler/core/ops_interfaces.td"
include "vpux/compiler/dialect/VPU/attributes.td"
include "vpux/compiler/dialect/VPU/ops_interfaces.td"
include "vpux/compiler/dialect/VPUIP/types.td"
include "vpux/compiler/dialect/VPUIP/attributes.td"
include "vpux/compiler/dialect/const/attributes.td"
include "vpux/compiler/NPU40XX/dialect/ELF/ops_interfaces.td"

include "mlir/Dialect/Quant/QuantOpsBase.td"
include "mlir/Interfaces/CopyOpInterface.td"
include "mlir/Interfaces/InferTypeOpInterface.td"
include "mlir/Interfaces/ViewLikeInterface.td"
include "mlir/Interfaces/SideEffectInterfaces.td"
include "mlir/IR/RegionKindInterface.td"
include "mlir/IR/SymbolInterfaces.td"

include "vpux/compiler/dialect/VPURegMapped/types.td"

//
// Base classes
//

class VPUASM_Op<string mnemonic, list<Trait> traits = []> :
        Op<
            VPUASM_Dialect,
            mnemonic,
            traits
        >;

class VPUASM_Instruction<string mnemonic, list<Trait> traits = []> :
        VPUASM_Op<
            mnemonic,
            !listconcat(
                traits,
                [
                    DeclareOpInterfaceMethods<ELF_WrappableOpInterface>,
                    Symbol,
                    IsolatedFromAbove
                ]
            )
        > {
}

class VPUASM_Memory<string mnemonic, list<Trait> traits = []> :
        VPUASM_Op<
            mnemonic,
            !listconcat(
                traits,
                [
                    IsolatedFromAbove,
                    Symbol
                ]
            )
        > {

}

//Separate the interface that represents the nature that an OP may reference another symbolic OP (aka it has symbolRef's)

//
// Buffers
//

//
// ConstOp
//

def VPUASM_ConstBufferOp :
        VPUASM_Memory<"ConstBuffer",
            [
                DeclareOpInterfaceMethods<ELF_BinaryOpInterface, ["serialize", "getBinarySize"]>,
                DeclareOpInterfaceMethods<ELF_WrappableOpInterface>,
            ]
        > {
    let summary = "Constant R/O buffer symbolic declaration";

    let arguments = (ins
        SymbolNameAttr:$sym_name,
        VPUASM_BufferTypeAttr:$buffer_type,
        Const_ContentAttr:$content
    );

    let assemblyFormat = [{
        $sym_name
        attr-dict
        $buffer_type `=` $content
    }];
}

//
// DeclareBufferOp
//

def VPUASM_DeclareBufferOp :
        VPUASM_Memory<"DeclareBuffer",
            [
                DeclareOpInterfaceMethods<ELF_BinaryOpInterface, ["serialize", "getBinarySize"]>,
                DeclareOpInterfaceMethods<ELF_WrappableOpInterface, ["getMemoryOffset", "setMemoryOffset"]>,
            ]
        > {
    let summary = "RunTime dynamic R/W buffer symbolic declaration";

    let arguments = (ins
        SymbolNameAttr:$sym_name,
        VPUASM_BufferTypeAttr:$buffer_type
    );

    let assemblyFormat = [{
        $sym_name
        attr-dict
        $buffer_type
    }];
}

def VPUASM_DeclareTaskBufferOp :
        VPUASM_Memory<"DeclareTaskBuffer",
            [
                DeclareOpInterfaceMethods<ELF_BinaryOpInterface, ["serialize", "getBinarySize"]>,
                DeclareOpInterfaceMethods<ELF_WrappableOpInterface>,
                VPUASM_IndexedTaskInterface
            ]
        > {

    let summary = "Buffer Op representing a discrete location of a task in runtime metadataBuffer";

    let arguments = (ins
        SymbolNameAttr:$sym_name,
        VPUASM_IndexTypeAttr:$task_index,
        VPURegMapped_TaskTypeAttr:$task_type
    );

    let assemblyFormat = [{
        $sym_name
        `idx` `(` $task_index `)`
        $task_type
        attr-dict
    }];
}

//
// Ops
//

//
// TaskAddrBufferOp
//

def VPUASM_DeclareTaskAddrBufOp :
    VPUASM_Memory<"DeclareTaskAddrBuffer",
        [
            DeclareOpInterfaceMethods<ELF_BinaryOpInterface, ["serialize", "getBinarySize"]>,
            DeclareOpInterfaceMethods<ELF_WrappableOpInterface,  ["getMemoryOffset", "setMemoryOffset"]>,
        ]> {

    let summary = "Symbolic representation of DeclareTaskAddrBuffOp";

    let arguments = (ins
        SymbolNameAttr:$sym_name,
        SymbolRefAttr:$first,
        SymbolRefAttr:$last,
        VPUASM_BufferTypeAttr:$buffer_type,
        VPURegMapped_TaskTypeAttr:$task_type
    );

    let assemblyFormat = [{
        $sym_name `(` $first `->` $last `)` $buffer_type $task_type attr-dict
    }];
}

//
// TaskSinkOp
//

def VPUASM_TaskSinkOp :
    VPUASM_Memory<"TaskSink",
        [
            DeclareOpInterfaceMethods<ELF_BinaryOpInterface, ["serialize", "getBinarySize"]>,
            DeclareOpInterfaceMethods<ELF_WrappableOpInterface,  ["getMemoryOffset", "setMemoryOffset"]>,
        ]> {

    let summary = "Symbolic representation of DeclareTaskAddrBuffOp";

    let arguments = (ins
        SymbolNameAttr:$sym_name,
        UI8Attr:$tile,
        VPURegMapped_TaskTypeAttr:$taskType
    );

    let assemblyFormat = [{
        $sym_name $tile $taskType attr-dict
    }];
}

//
// IOBindings
//

def VPUASM_IOBindingsOp:
        VPUASM_Op<"IOBindings",
            [
                IsolatedFromAbove,
                HasParent<"mlir::ModuleOp">,
                NoRegionArguments
            ]
            #GraphRegionNoTerminator.traits
        > {
    let summary = "Mapped inference level I/O Network description";

    let description = [{
        This operation is bound to the main MLIR module and explicitly encapsulates the I/O information that the network will
        work with at buffer and location level.
    }];

    let regions = (region
        SizedRegion<1>:$inputDeclarations,
        SizedRegion<1>:$outputDeclarations,
        SizedRegion<1>:$profilingBuffDeclarations
    );

    let extraClassDeclaration = [{
        size_t getNetInputsCount();
        vpux::SmallVector<vpux::VPUASM::DeclareBufferOp, 1> getInputDeclarationsOps();

        size_t getNetOutputsCount();
        vpux::SmallVector<vpux::VPUASM::DeclareBufferOp, 1> getOutputDeclarationsOps();

        size_t getProfilingBuffsCount();
        vpux::SmallVector<vpux::VPUASM::DeclareBufferOp, 1> getProfilingBuffDeclarationsOps();

        static VPUASM::IOBindingsOp getFromModule(
            mlir::ModuleOp module
        );
    }];

    let builders = [
        OpBuilder<
            (ins)
        >
    ];

    let skipDefaultBuilders = 1;

    let assemblyFormat = [{
        attr-dict
        `inputDeclarations` `:` $inputDeclarations
        `outputDeclarations` `:` $outputDeclarations
        `profilingBuffDeclarations` `:` $profilingBuffDeclarations
    }];
}

//
// MappedInferenceOp_37XX
//

def VPUASM_MappedInferenceOp_37XX :
        VPUASM_Instruction<"MappedInference_37XX",
            [
                DeclareOpInterfaceMethods<ELF_BinaryOpInterface, ["serialize", "getBinarySize"]>
            ]
        > {
    let summary = "Task representing the MappedInference structure on 37XX";

    let arguments = (ins
        SymbolNameAttr:$sym_name,
        OptionalAttr<SymbolRefArrayAttr>:$dmaTasks,
        OptionalAttr<SymbolRefAttr>:$invariantTasks,
        OptionalAttr<SymbolRefAttr>:$variantTasks,
        OptionalAttr<SymbolRefAttr>:$actKernelRanges,
        OptionalAttr<SymbolRefAttr>:$actKernelInvocations,
        OptionalAttr<SymbolRefAttr>:$barrierTasks,
        OptionalAttr<SymbolRefAttr>:$actShaveRt,
        OptionalAttr<SymbolRefArrayAttr>:$actShaveStacks,
        I64ArrayAttr:$dmaCount,
        UI32Attr:$invariantCount,
        UI32Attr:$variantCount,
        UI32Attr:$actKernelRangesCount,
        UI32Attr:$actKernelInvocationsCount,
        UI32Attr:$barrierCount
    );

    let assemblyFormat = [{
    attr-dict
        $sym_name `:`
        (`dmas` `(` $dmaTasks^ `)`)?
        (`invariants` `(` $invariantTasks^ `)`)?
        (`variants` `(` $variantTasks^ `)`)?
        (`actKernelRanges` `(` $actKernelRanges^ `)`)?
        (`actKernelInvocations` `(` $actKernelInvocations^ `)`)?
        (`barriers` `(` $barrierTasks^ `)`)?
        (`actShaveRt` `(` $actShaveRt^ `)`)?
        (`actShaveStacks` `(` $actShaveStacks^ `)`)?
        `dmaCount` `(` $dmaCount `)`
        `invariantCount` `(` $invariantCount `)`
        `variantCount` `(` $variantCount `)`
        `actKernelRangesCount` `(` $actKernelRangesCount `)`
        `actKernelInvocationsCount` `(` $actKernelInvocationsCount `)`
        `barrierCount` `(` $barrierCount `)`
    }];
}

//
// MappedInferenceOp
//

def VPUASM_MappedInferenceOp :
        VPUASM_Instruction<"MappedInference",
            [
                DeclareOpInterfaceMethods<ELF_BinaryOpInterface, ["serialize", "getBinarySize"]>,
                DeclareOpInterfaceMethods<ELF_RelocatableOpInterface>
            ]
        > {
    let summary = "Task representing the MappedInference structure";

    let arguments = (ins
        SymbolNameAttr:$sym_name,
        OptionalAttr<SymbolRefArrayOfArraysAttr>:$dmaTasks,
        OptionalAttr<SymbolRefArrayAttr>:$invariantTasks,
        OptionalAttr<SymbolRefArrayAttr>:$variantTasks,
        OptionalAttr<SymbolRefArrayAttr>:$actKernelRanges,
        OptionalAttr<SymbolRefArrayAttr>:$actKernelInvocations,
        OptionalAttr<SymbolRefAttr>:$mediaTasks,
        OptionalAttr<SymbolRefAttr>:$barrierTasks,
        OptionalAttr<SymbolRefAttr>:$actShaveRt,
        OptionalAttr<SymbolRefArrayAttr>:$actShaveStacks,
        OptionalAttr<SymbolRefAttr>:$managedMappedInference,
        I64ArrayOfArraysAttr:$dmaCount,
        I64ArrayAttr:$invariantCount,
        I64ArrayAttr:$variantCount,
        I64ArrayAttr:$actKernelRangesCount,
        I64ArrayAttr:$actKernelInvocationsCount,
        I64Attr:$mediaCount,
        I64Attr:$barrierCount,
        OptionalAttr<SymbolRefAttr>:$dmaHwpBase,
        OptionalAttr<SymbolRefAttr>:$hwpWorkpointCfg
    );

    let assemblyFormat = [{
    attr-dict
        $sym_name `:`
        (`dmas` `(` $dmaTasks^ `)`)?
        (`invariants` `(` $invariantTasks^ `)`)?
        (`variants` `(` $variantTasks^ `)`)?
        (`actKernelRanges` `(` $actKernelRanges^ `)`)?
        (`actKernelInvocations` `(` $actKernelInvocations^ `)`)?
        (`mediaTasks` `(` $mediaTasks^ `)`)?
        (`barriers` `(` $barrierTasks^ `)`)?
        (`actShaveRt` `(` $actShaveRt^ `)`)?
        (`actShaveStacks` `(` $actShaveStacks^ `)`)?
        (`managedMappedInference` `(` $managedMappedInference^ `)`)?
        `dmaCount` `(` $dmaCount `)`
        `invariantCount` `(` $invariantCount `)`
        `variantCount` `(` $variantCount `)`
        `actKernelRangesCount` `(` $actKernelRangesCount `)`
        `actKernelInvocationsCount` `(` $actKernelInvocationsCount `)`
        `mediaCount` `(` $mediaCount `)`
        `barrierCount` `(` $barrierCount `)`
        (`dmaHwpBase` `(` $dmaHwpBase^ `)`)?
        (`hwpWorkpointCfg` `(` $hwpWorkpointCfg^ `)`)?
    }];
}


//
// ManagedMappedInferenceOp
//

def VPUASM_ManagedMappedInferenceOp :
        VPUASM_Instruction<"ManagedMappedInference",
            [
                DeclareOpInterfaceMethods<ELF_BinaryOpInterface, ["serialize", "getBinarySize"]>,
                DeclareOpInterfaceMethods<ELF_RelocatableOpInterface>
            ]
        > {

    let summary = [{Task representing the alternative "Managed Mapped Inference" data structure}];

    let arguments = (ins
        SymbolNameAttr:$sym_name,
        OptionalAttr<SymbolRefArrayOfArraysAttr>:$dmaTasks,
        OptionalAttr<SymbolRefAttr>:$workItems,
        OptionalAttr<SymbolRefAttr>:$barrierTasks,
        OptionalAttr<SymbolRefAttr>:$bootstrapTasks,

        I64ArrayOfArraysAttr:$dmaCount,
        I64Attr:$workItemsCount,
        I64Attr:$barrierCount,
        IntAttr:$final_barrier_id,
        I64Attr:$bootstrapTasksCount,
        I64Attr:$bootsrapWorkItemsCount
        );

    let assemblyFormat = [{
        $sym_name `:`
        `dmas`  $dmaTasks
        `workItems` `(` $workItems `)`
        `barrierTasks` `(` $barrierTasks `)`
        (`bootstrapTasks` `(` $bootstrapTasks^ `)`)?

        attr-dict
    }];
}

//
// ConfigureBarrierOp
//

def VPUASM_ConfigureBarrierOp :
        VPUASM_Instruction<"ConfigureBarrier",
            [
                DeclareOpInterfaceMethods<ELF_BinaryOpInterface, ["serialize", "getBinarySize"]>,
                VPUASM_IndexedTaskInterface
            ]
        > {
    let summary = "A task to configure the setup for a barrier";

    let arguments = (ins
        SymbolNameAttr:$sym_name,
        VPUASM_IndexTypeAttr:$task_index,

        OptionalAttr<VPUASM_IndexTypeAttr>:$work_item_idx,
        UI8Attr:$id,
        SI64Attr:$next_same_id,
        UI8Attr:$producer_count,
        UI8Attr:$consumer_count
    );

    let hasVerifier = 1;

    let assemblyFormat = [{
        $sym_name
        `idx` `(` $task_index `)`
        (`workItemIdx` `(` $work_item_idx^ `)` )?
        `(` $id `)`
        `=` `>` `(` $next_same_id `)`
        `counts` `(` $producer_count `:` $consumer_count `)`
        attr-dict
    }];
}

//
// BootstrapOp
//

def VPUASM_BootstrapOp :
        VPUASM_Instruction<"Bootstrap",
            [
                DeclareOpInterfaceMethods<ELF_BinaryOpInterface, ["serialize", "getBinarySize"]>,
                VPUASM_IndexedTaskInterface
            ]
        > {
    let summary = "A task to configure the setup for a barrier";

    let arguments = (ins
        SymbolNameAttr:$sym_name,
        UI32Attr:$barrier_id
    );

    let assemblyFormat = [{
        $sym_name
        attr-dict
    }];
}

//
// ManagedBarrierOp
//

def VPUASM_ManagedBarrierOp :
        VPUASM_Instruction<"ManagedBarrier",
            [
                DeclareOpInterfaceMethods<ELF_BinaryOpInterface, ["serialize", "getBinarySize"]>,
                VPUASM_IndexedTaskInterface
            ]
        > {
    let summary = "A task to configure the setup for a barrier, with workItem attached";
    let description = [{Virtually the same as ConfigureBarrierOp, however since this will be managed barrier, it will have
                        a different memory footprint in the serialized form. Intended as temporary until we can figure out how
                        to unify representations}];

    let arguments = (ins
        SymbolNameAttr:$sym_name,
        VPUASM_IndexTypeAttr:$task_index,

        OptionalAttr<VPUASM_IndexTypeAttr>:$work_item_idx,
        DefaultValuedAttr<UI32Attr, "0">:$work_item_count,
        UI8Attr:$id,
        SI64Attr:$next_same_id,
        UI8Attr:$producer_count,
        UI8Attr:$consumer_count
    );

    let hasVerifier = 1;

    let assemblyFormat = [{
        $sym_name
        `idx` `(` $task_index `)`
        (`workItemIdx` `(` $work_item_idx^ `)` )?
        `(` $id `)`
        `=` `>` `(` $next_same_id `)`
        `counts` `(` $producer_count `:` $consumer_count `)`
        attr-dict
    }];
}

//
// WorkItemOp
//

def VPUASM_WorkItemOp :
        VPUASM_Instruction<"WorkItem",
            [
                DeclareOpInterfaceMethods<ELF_BinaryOpInterface, ["serialize", "getBinarySize"]>,
                VPUASM_IndexedTaskInterface,
                DeclareOpInterfaceMethods<ELF_RelocatableOpInterface>,
            ]
        > {

    let summary = "Work Item Task";

    let arguments = (ins
        SymbolNameAttr:$sym_name,
        VPUASM_IndexTypeAttr:$task_index, //workitem index in the list of tasks
        VPUASM_IndexTypeAttr:$real_task_index, // index of the actual task dpu or dma or shave
        VPURegMapped_TaskTypeAttr:$task_type,
        SymbolRefAttr:$first_task,
        I64Attr:$task_count
    );

    let assemblyFormat = [{
        $sym_name
        `idx` `(` $task_index `)`
        `real_task_index` `(` $real_task_index `)`
        `task_type` `(` $task_type `)`
        `first_task` `(` $first_task `)`
        `task_count` `(` $task_count `)`
        attr-dict
    }];
}

//
// NNDMAOp
//

def VPUASM_NNDMAOp :
        VPUASM_Instruction<"NNDMA",
            [
                DeclareOpInterfaceMethods<ELF_BinaryOpInterface, ["serialize", "getBinarySize"]>,
                VPUASM_IndexedTaskInterface
            ]
        > {
    let summary = "NN DMA task";

    let arguments = (ins
        SymbolNameAttr:$sym_name,
        VPUASM_IndexTypeAttr:$task_index,

        OptionalAttr<SymbolRefAttr>:$task_location,
        OptionalAttr<SymbolRefAttr>:$next_link,
        SymbolRefAttr:$input,
        SymbolRefArrayAttr:$output_buffs,
        UI8ArrayAttr:$waitBarriers,
        UI8ArrayAttr:$updateBarriers,
        UI64Attr:$start_after,
        UI64Attr:$clean_after,
        DefaultValuedAttr<VPUIP_DMAAccModeAttr, "VPUIP::DMAAccMode::DISABLE">:$acceleration_mode,
        UnitAttr:$is_out_of_order,
        UnitAttr:$is_critical,
        UnitAttr:$enable_msc,
        OptionalAttr<SymbolRefAttr>:$act_compression_size_entry,
        VPUIP_DMADescriptorAttr:$dma_descriptor,
        OptionalAttr<IntAttr>:$dma_hwp_id,
        OptionalAttr<I64ArrayAttr>:$tile_indexes,
        OptionalAttr<SymbolRefAttr>:$indices
    );

    let builders = [
        OpBuilder<
            (ins "mlir::Value":$src, "mlir::Value":$dst)
        >
    ];

    let extraClassDeclaration = [{
        static vpux::VPURegMapped::TaskType getTaskType() {
            return vpux::VPURegMapped::TaskType::DMA;
        }
    }];

    let assemblyFormat = [{
        $sym_name
        `idx` `(` $task_index `)`
        (`taskLocation` `(` $task_location^ `)`)?
        (`links` `(` $next_link^ `)`)?
        `input` `(` $input `)`
        `outputs` `(` $output_buffs `)`
        `waits` `(` $waitBarriers `)`
        `updates` `(` $updateBarriers `)`
        `start_after` `(` $start_after `)`
        `clean_after` `(` $clean_after `)`
        `descriptor` `(` $dma_descriptor `)`
        `acceleration_mode` `(` $acceleration_mode `)`
        (`act_compression_size_entry` `(` $act_compression_size_entry^ `)`)?
        (`is_out_of_order` `(` $is_out_of_order^ `)`)?
        (`is_critical` `(` $is_critical^ `)`)?
        (`tile_indexes` `(` $tile_indexes^ `)`)?
        (`indices` `(` $indices^ `)`)?
        attr-dict
    }];

    let hasVerifier = 1;
}

//
// Activation Kernel Ops
//

//
// ActShaveRtOp
//

def VPUASM_ActShaveRtOp :
        VPUASM_Op<"ActShaveRt",
            [
                DeclareOpInterfaceMethods<ELF_BinaryOpInterface, ["serialize", "getBinarySize"]>,
                DeclareOpInterfaceMethods<ELF_WrappableOpInterface>,
                Symbol,
                IsolatedFromAbove
            ]
        > {
    let summary = "Declaration of Act Shave Management Kernel";

    let arguments = (ins
        SymbolNameAttr:$sym_name,
        StrAttr:$kernel_path
    );

    let assemblyFormat = [{
        $sym_name attr-dict `kernel` `(` $kernel_path `)`
    }];
}

//
// DeclareKernelTextOp
//

def VPUASM_DeclareKernelTextOp :
        VPUASM_Instruction<"DeclareKernelText",
            [
                DeclareOpInterfaceMethods<ELF_BinaryOpInterface, ["serialize", "getBinarySize"]>
            ]
        > {
    let summary = "Declaration of Software Kernel .text ";

    let arguments = (ins
        SymbolNameAttr:$sym_name,
        StrAttr:$kernel_path
    );

    let assemblyFormat = [{
        $sym_name attr-dict `:` $kernel_path
    }];
}


//
// DeclareKernelDataOp
//


def VPUASM_DeclareKernelDataOp :
        VPUASM_Instruction<"DeclareKernelData",
            [
                DeclareOpInterfaceMethods<ELF_BinaryOpInterface, ["serialize", "getBinarySize"]>
            ]
        > {
    let summary = "Declaration of Software Kernel .data";

    let arguments = (ins
        SymbolNameAttr:$sym_name,
        StrAttr:$kernel_path
    );

    let assemblyFormat = [{
        $sym_name attr-dict `:` $kernel_path
    }];
}

//
// DeclareKernelEntryOp
//

def VPUASM_DeclareKernelEntryOp :
        VPUASM_Op<"DeclareKernelEntry",
            [
                IsolatedFromAbove
            ]
        > {
    let summary = "Declaration of Kernel Entry";

    let arguments = (ins
        SymbolNameAttr:$sym_name,
        StrAttr:$kernel_path
    );

    let assemblyFormat = [{
        $sym_name attr-dict `:` $kernel_path
    }];

    let extraClassDeclaration = [{
        uint32_t getKernelEntry();
    }];

}

//
// KernelParamsOp
//

def VPUASM_KernelParamsOp :
        VPUASM_Instruction<"KernelParams",
            [
                DeclareOpInterfaceMethods<ELF_RelocatableOpInterface>,
                DeclareOpInterfaceMethods<ELF_BinaryOpInterface, ["serializeCached", "getBinarySizeCached"]>
            ]
        > {
    let summary = "Kernel Params";

    let arguments = (ins
        SymbolNameAttr:$sym_name,
        SymbolRefArrayAttr:$inputs,
        SymbolRefArrayAttr:$outputs,
        StrAttr:$kernel_type,
        ElementsAttr:$kernel_params
    );

    let extraClassDeclaration = [{
        size_t getParamsStructSize();
    }];

    let assemblyFormat = [{
        $sym_name
        `inputs` `(` $inputs `)`
        `outputs` `(` $outputs `)`
        `kernel_type` `(` $kernel_type `)`
        `kernel_params` `(` $kernel_params `)`
        attr-dict

    }];
}

//
// ActKernelRangeOp
//

def VPUASM_ActKernelRangeOp :
        VPUASM_Instruction<"ActKernelRange",
            [
                DeclareOpInterfaceMethods<ELF_BinaryOpInterface, ["serialize", "getBinarySize"]>,
                VPUASM_IndexedTaskInterface
            ]
        > {
    let summary = "Activation Kernel Range";

    let arguments = (ins
        SymbolNameAttr:$sym_name,
        VPUASM_IndexTypeAttr:$task_index,

        OptionalAttr<SymbolRefAttr>:$task_location,
        OptionalAttr<SymbolRefAttr>:$kernel_text,
        OptionalAttr<SymbolRefAttr>:$kernel_entry,
        SymbolRefAttr:$kernelTaskType
    );

    let assemblyFormat = [{
        $sym_name
        `idx` `(` $task_index `)`
        (`taskLocation` `(` $task_location^ `)`)?
        `kernelTaskType` `(` $kernelTaskType `)`
        (`calls` $kernel_text^ )?
        (`:` $kernel_entry^ )?
        attr-dict
    }];
}

//
// ActKernelInvocationOp
//

def VPUASM_ActKernelInvocationOp :
        VPUASM_Instruction<"ActKernelInvocation",
            [
                DeclareOpInterfaceMethods<ELF_BinaryOpInterface, ["serialize", "getBinarySize"]>,
                VPUASM_IndexedTaskInterface
            ]
        > {
    let summary = "Activation Kernel Invocation";

    let arguments = (ins
        SymbolNameAttr:$sym_name,
        VPUASM_IndexTypeAttr:$task_index,

        OptionalAttr<SymbolRefAttr>:$task_location,
        SymbolRefAttr:$kernel_range,
        OptionalAttr<SymbolRefAttr>:$kernel_data,
        SymbolRefAttr:$kernel_params,
        UI8ArrayAttr:$waitBarriers,
        UI8ArrayAttr:$updateBarriers,
        OptionalAttr<SymbolRefAttr>:$profiling_data,
        DefaultValuedAttr<UI64Attr, "0">:$tile,
        UI64Attr:$start_after,
        UI64Attr:$clean_after,
        UI64Attr:$range_index
    );

    let extraClassDeclaration = [{
        static vpux::VPURegMapped::TaskType getTaskType() {
            return vpux::VPURegMapped::TaskType::ActKernelInvocation;
        }
    }];

    let assemblyFormat = [{
        $sym_name
        `idx` `(` $task_index `)`
        `taskLocation` `(` $task_location `)`
        `->` $kernel_range `(` (`kernel_data` `:` $kernel_data^ `,`)? `kernel_params` `:` $kernel_params  `)`
        (`profiling_data` `(` $profiling_data^ `)`)?
        `waits` `(` $waitBarriers `)`
        `updates` `(` $updateBarriers `)`
        `tile` `(` $tile `)`
        `start_after` `(` $start_after `)`
        `clean_after` `(` $clean_after `)`
        `range_index` `(` $range_index `)`
        attr-dict
    }];
}

//
// DPU Variant Op
//

def VPUASM_DPUVariantOp :
        VPUASM_Instruction<"DPUVariant",
            [
                DeclareOpInterfaceMethods<ELF_BinaryOpInterface, ["serialize", "getBinarySize"]>,
                VPUASM_IndexedTaskInterface
            ]
            # GraphRegionNoTerminator.traits
        > {

    let summary = "DPU Variant Op";

    let arguments = (ins
        SymbolNameAttr:$sym_name,
        VPUASM_IndexTypeAttr:$task_index,

        OptionalAttr<SymbolRefAttr>:$task_location,
        OptionalAttr<SymbolRefAttr>:$next_link,
        SymbolRefAttr:$invariant,
        SymbolRefAttr:$invariant_task_location,

        OptionalAttr<SymbolRefAttr>:$weights,
        OptionalAttr<SymbolRefAttr>:$weight_table,
        VPUIP_NCETaskTypeAttr:$nce_task_type,
        I64ArrayAttr:$inStart,
        I64ArrayAttr:$inEnd,
        I64ArrayAttr:$start,
        I64ArrayAttr:$end,
        VPU_PaddingAttr:$pad,
        VPU_MPEModeAttr:$mpe_mode,
        OptionalAttr<IntAttr>:$cluster_id,
        OptionalAttr<DPUHaloRegionArrayAttr>: $haloRegions,
        OptionalAttr<IntAttr>:$workload_id,
        UnitAttr:$lut_read
    );

    let assemblyFormat = [{
        $sym_name
        `idx` `(` $task_index `)`
        `taskLocation` `(` $task_location `)`
        (`nextLink` `(` $next_link^ `)`)?
        `invariant` $invariant
        `calls` $invariant_task_location
        (`weights` `(` $weights^ `)`)?
        (`weight_table` `(` $weight_table^ `)`)?
        attr-dict
    }];
}

def VPUASM_PPETaskOp : VPU_PPETaskOpBase<
    VPUASM_Dialect,
    "PPETask",
    [ParentOneOf<["vpux::VPUASM::DPUInvariantOp", "vpux::VPUASM::DPUInvariantOp_37XX"]>]
> {}

//
// DPU Invariant Op
//

def VPUASM_DPUInvariantOp :
        VPUASM_Instruction<"DPUInvariant",
            [
                DeclareOpInterfaceMethods<ELF_BinaryOpInterface, ["serialize", "getBinarySize"]>,
                VPUASM_IndexedTaskInterface
            ]
            # GraphRegionNoTerminator.traits
        > {

    let summary = "DPU Invariant Op";

    let arguments = (ins
        SymbolNameAttr:$sym_name,
        VPUASM_IndexTypeAttr:$task_index,

        OptionalAttr<SymbolRefAttr>:$task_location,
        SymbolRefAttr:$input,
        OptionalAttr<SymbolRefAttr>:$input_sparsity_map,
        OptionalAttr<SymbolRefAttr>:$input_storage_element_table,

        OptionalAttr<SymbolRefAttr>:$weights,
        OptionalAttr<SymbolRefAttr>:$weights_sparsity_map,
        OptionalAttr<SymbolRefAttr>:$weight_table,
        OptionalAttr<SymbolRefAttr>:$spr_lookup_table,

        OptionalAttr<SymbolRefAttr>:$output,
        OptionalAttr<SymbolRefAttr>:$output_sparsity_map,
        OptionalAttr<SymbolRefAttr>:$profiling_data,

        OptionalAttr<VPUASM_BufferTypeAttr>:$output_type_continued,

        UI8ArrayAttr:$waitBarriers,
        UI8ArrayAttr:$updateBarriers,

        VPUIP_NCETaskTypeAttr:$nce_task_type,
        VPU_MPEModeAttr:$mpe_frequent_mode,

        OptionalAttr<I64ArrayAttr>:$kernel_size,
        OptionalAttr<I64ArrayAttr>:$kernel_strides,
        OptionalAttr<VPU_PaddingAttr>:$kernel_padding,
        OptionalAttr<IntAttr>:$activation_window_channel_length,
        UnitAttr:$is_continued,
        OptionalAttr<IntAttr>:$cm_sp_pattern,
        UnitAttr:$input_channels_compression,
        OptionalAttr<IntAttr>:$out_channel_offset,
        UnitAttr:$is_superdense,
        OptionalAttr<BoolAttr>:$is_inplace,
        OptionalAttr<IntAttr>:$input_se_size,
        OptionalAttr<IntAttr>:$output_se_size,
        UnitAttr:$is_permute_quantize,
        UnitAttr:$is_small_kernel_optimized,

        UI64Attr:$start_after,
        UI64Attr:$clean_after,

        UI64Attr:$variant_count,
        UI32Attr:$first_variant_index,
        UI32Attr:$last_variant_index
    );

    let regions = (region
        SizedRegion<1>:$ppe
    );

    let extraClassDeclaration = [{
        static vpux::VPURegMapped::TaskType getTaskType() {
            return vpux::VPURegMapped::TaskType::DPUInvariant;
        }
    }];

    let assemblyFormat = [{
        $sym_name
        `idx` `(` $task_index `)`
        `taskLocation` `(` $task_location `)`
        `input` `(` $input `)`
        (`input_sparsity_map` `(` $input_sparsity_map^ `)`)?
        (`input_storage_element_table` `(` $input_storage_element_table^ `)`)?
        (`weights` `(` $weights^ `)`)?
        (`weights_sparsity_map` `(` $weights_sparsity_map^ `)`)?
        (`weight_table` `(` $weight_table^ `)`)?
        (`spr_lookup_table` `(` $spr_lookup_table^ `)`)?
        (`output` `(` $output^ `)`)?
        (`output_sparsity_map` `(` $output_sparsity_map^ `)`)?
        (`profiling_data` `(` $profiling_data^ `)`)?
        `waits` `(` $waitBarriers `)`
        `updates` `(` $updateBarriers `)`
        attr-dict
        `PPE` `:` $ppe
    }];
}

//
// DPU Variant Op 37XX
//

def VPUASM_DPUVariantOp_37XX :
        VPUASM_Instruction<"DPUVariant_37XX",
            [
                DeclareOpInterfaceMethods<ELF_BinaryOpInterface, ["serialize", "getBinarySize"]>,
                VPUASM_IndexedTaskInterface
            ]
        > {

    let summary = "DPU Variant Op_37XX";

    let arguments = (ins
        SymbolNameAttr:$sym_name,
        VPUASM_IndexTypeAttr:$task_index,

        OptionalAttr<SymbolRefAttr>:$task_location,
        SymbolRefAttr:$invariant,
        I64ArrayAttr:$start,
        I64ArrayAttr:$end,
        VPU_PaddingAttr:$pad,
        VPU_MPEModeAttr:$mpe_mode,
        OptionalAttr<IntAttr>:$cluster_id
    );

    let assemblyFormat = [{
        $sym_name
        `idx` `(` $task_index `)`
        `taskLocation` `(` $task_location `)`
        `calls` $invariant
        attr-dict
    }];
}

//
// DPU Invariant Op 37XX
//

def VPUASM_DPUInvariantOp_37XX :
        VPUASM_Instruction<"DPUInvariant_37XX",
            [
                DeclareOpInterfaceMethods<ELF_BinaryOpInterface, ["serialize", "getBinarySize"]>,
                VPUASM_IndexedTaskInterface
            ]
            # GraphRegionNoTerminator.traits
        > {

    let summary = "DPU Invariant Op 37XX";

    let arguments = (ins
        SymbolNameAttr:$sym_name,
        VPUASM_IndexTypeAttr:$task_index,

        OptionalAttr<SymbolRefAttr>:$task_location,
        SymbolRefAttr:$input,
        OptionalAttr<SymbolRefAttr>:$input_sparsity_map,
        OptionalAttr<SymbolRefAttr>:$input_storage_element_table,

        OptionalAttr<SymbolRefAttr>:$weights,
        OptionalAttr<SymbolRefAttr>:$weights_sparsity_map,
        OptionalAttr<SymbolRefAttr>:$weight_table,

        //Parent I/O's needed until we fully integrate VPUIPDPU
        SymbolRefAttr:$parent_input,
        OptionalAttr<SymbolRefAttr>:$parent_input_sparsity_map,
        OptionalAttr<SymbolRefAttr>:$parent_input_storage_element_table,

        SymbolRefAttr:$parent_output,

        SymbolRefArrayAttr:$output_buffs,

        OptionalAttr<SymbolRefAttr>:$profiling_data,

        UI8ArrayAttr:$waitBarriers,
        UI8ArrayAttr:$updateBarriers,

        VPUIP_NCETaskTypeAttr:$nce_task_type,
        VPU_MPEModeAttr:$mpe_frequent_mode,

        OptionalAttr<I64ArrayAttr>:$kernel_size,
        OptionalAttr<I64ArrayAttr>:$kernel_strides,
        OptionalAttr<VPU_PaddingAttr>:$kernel_padding,
        OptionalAttr<IntAttr>:$activation_window_channel_length,
        UnitAttr:$is_continued,
        OptionalAttr<IntAttr>:$cm_sp_pattern,
        UnitAttr:$input_channels_compression,
        UnitAttr:$is_segmented,
        OptionalAttr<IntAttr>:$out_channel_offset,

        UI64Attr:$start_after,
        UI64Attr:$clean_after
    );

    //PPE needed until we fully integrate VPUIPDPU
    let regions = (region
        SizedRegion<1>:$ppe

    );

    let extraClassDeclaration = [{
        static vpux::VPURegMapped::TaskType getTaskType() {
            return vpux::VPURegMapped::TaskType::DPUInvariant;
        }
    }];

    let assemblyFormat = [{
        $sym_name
        `idx` `(` $task_index `)`
        `taskLocation` `(` $task_location `)`
        `input` `(` $input `)`
        (`input_sparsity_map` `(` $input_sparsity_map^ `)`)?
        (`input_storage_element_table` `(` $input_storage_element_table^ `)`)?
        (`weights` `(` $weights^ `)`)?
        (`weights_sparsity_map` `(` $weights_sparsity_map^ `)`)?
        (`weight_table` `(` $weight_table^ `)`)?
        `parent_input` `(` $parent_input `)`
        (`parent_input_sparsity_map` `(` $parent_input_sparsity_map^ `)`)?
        (`parent_input_storage_element_table` `(` $parent_input_storage_element_table^ `)`)?
        `parent_output` `(` $parent_output `)`
        `outputs` `(` $output_buffs `)`
        (`profiling_data` `(` $profiling_data^ `)`)?
        `waits` `(` $waitBarriers `)`
        `updates` `(` $updateBarriers `)`
        attr-dict
        `PPE` `:` $ppe
    }];
}

//
// SymbolizeValueOp
//

def VPUASM_SymbolizeValueOp :
    VPUASM_Op<"SymbolizeValueOp",
        [
            Symbol
        ]
    > {

    let summary = "Symbolize any SSA value";

    let description = [{
        In cases where mixing operations that return SSA values into symbolic use-def-chains.
        Basically this op is  a "materialization op" that materializez any type into a "Symbolic type"
    }];

    let arguments = (ins
        AnyType:$input,
        SymbolNameAttr:$sym_name
    );

    let assemblyFormat = [{
        $sym_name `(` $input `:` type($input) `)` attr-dict
    }];
}

//
// Network Metadtata Op
//

def VPUASM_NetworkMetadataOp :
        VPUASM_Instruction<"NetworkMetadata",
            [
                DeclareOpInterfaceMethods<ELF_BinaryOpInterface, ["serialize", "getBinarySize"]>,
                VPUASM_IndexedTaskInterface
            ]
        > {
    let summary = "Network Metadata Op";

    let arguments = (ins
        SymbolNameAttr:$sym_name
    );

    let extraClassDeclaration = [{
        void serialize(elf::writer::BinaryDataSection<uint8_t>& binDataSection, ::elf::NetworkMetadata& metadata);
    }];

    let assemblyFormat = [{
        $sym_name
        attr-dict
    }];
}

//
// Profiling Metadata Op
//

def VPUASM_ProfilingMetadataOp :
        VPUASM_Instruction<"ProfilingMetadata",
            [
                DeclareOpInterfaceMethods<ELF_BinaryOpInterface, ["serialize", "getBinarySize"]>
            ]
        > {
    let summary = "Profiling Metadata Op";

    let arguments = (ins
        SymbolNameAttr:$sym_name,
        ElementsAttr:$metadata
    );

    let assemblyFormat = [{
        $sym_name
        attr-dict
    }];
}

//
// M2IOp
//

def VPUASM_M2IOp :
        VPUASM_Instruction<"M2I",
            [
                DeclareOpInterfaceMethods<ELF_BinaryOpInterface, ["serialize", "getBinarySize"]>,
                VPUASM_IndexedTaskInterface
            ]
        > {
    let summary = "M2I task op";

    let arguments = (ins
        SymbolNameAttr:$sym_name,
        VPUASM_IndexTypeAttr:$task_index,

        OptionalAttr<SymbolRefAttr>:$taskLocation,
        OptionalAttr<SymbolRefAttr>:$next_link,
        SymbolRefAttr:$input,
        SymbolRefAttr:$output_buff,
        OptionalAttr<SymbolRefAttr>:$profiling_data,

        UnitAttr:$do_csc,
        UnitAttr:$do_norm,
        VPU_M2iColorFmtAttr:$inFmt,
        VPU_M2iColorFmtAttr:$outFmt,

        UnitAttr:$chroma_in_reverse_channels,
        UnitAttr:$chroma_out_reverse_channels,
        UnitAttr:$luma_in_reverse_channels,
        UnitAttr:$luma_out_reverse_channels,
        UI32Attr:$scale_factor_x,
        UI32Attr:$scale_factor_y,
        OptionalAttr<F64ArrayAttr>:$norm,
        OptionalAttr<UI32Attr>:$tile_offset_x,
        OptionalAttr<UI32Attr>:$tile_offset_y,
        DefaultValuedAttr<VPU_M2iInterpAttr, "vpux::VPU::M2iInterp::NEAREST">:$interp,

        UI8ArrayAttr:$waitBarriers,
        UI8ArrayAttr:$updateBarriers,
        UI64Attr:$start_after,
        UI64Attr:$clean_after
    );

    let extraClassDefinition = [{
        static vpux::VPURegMapped::TaskType getTaskType() {
            return vpux::VPURegMapped::TaskType::M2I;
        }
    }];

    let assemblyFormat = [{
         $sym_name
        `idx` `(` $task_index `)`
        (`taskLocation` `(` $taskLocation^ `)`)?
        (`links` `(` $next_link^ `)`)?
        `inputs` `(` $input `)`
        `outputs` `(` $output_buff `)`
        (`profiling_data` `(` $profiling_data^ `)`)?
        attr-dict
    }];
}

//
// MappedInferenceVersionOp
//

def MappedInferenceVersionOp :
        VPUASM_Op<"MappedInferenceVersion",
            [
                DeclareOpInterfaceMethods<ELF_BinaryOpInterface, ["serialize", "getBinarySize"]>,
                DeclareOpInterfaceMethods<ELF_WrappableOpInterface>,
                Symbol
            ]
        > {
    let summary = "Represents a versioning mechanism for Mapped Inference. Only trivially defined at this level.";

    let arguments = (ins
          SymbolNameAttr:$sym_name
        );

    let assemblyFormat = [{
        attr-dict
        }];

    let builders = [
        OpBuilder<(ins)>
        ];
}

//
// PlatformInfoOp
//

def PlatformInfoOp :
        VPUASM_Op<"PlatformInfo",
            [
                DeclareOpInterfaceMethods<ELF_BinaryOpInterface, ["serialize", "getBinarySize"]>,
                DeclareOpInterfaceMethods<ELF_WrappableOpInterface>,
                Symbol
            ]
        > {
    let summary = "Represents an op describing various platform information, such as arch, revision, etc.";

    let arguments = (ins
          SymbolNameAttr:$sym_name,
          VPU_ArchKindAttr:$archKind
        );

    let assemblyFormat = [{
        attr-dict
        }];

    let builders = [
        OpBuilder<(ins)>,
        OpBuilder<(ins "vpux::VPU::ArchKind":$archKind)>
        ];
}

#endif
